use crate::{Context, Data, Exception};
use std::{io, str::FromStr};
use poise::serenity_prelude as serenity;
use reqwest::Url;
use serde::{Deserialize, Serialize};
use ::serenity::{all::CreateEmbed, client, futures};
use futures::{Stream, StreamExt};

/* 
use if you're using item.json generated by createItems.py

#[derive(Serialize, Deserialize, Debug)]
struct Item {
    id: u16,
    item: ItemData,
}

#[derive(Serialize, Deserialize, Debug)]
struct ItemData {
    name_en: String,
    name_ja: String,
    description_en: String,
    description_ja: String,
    category_en: String,
    category_ja: String,
    implement_patch_id: u8,
    url: String,
    icon_url: String,
    hd_icon_url: String,
}
*/

#[derive(Serialize, Deserialize, Debug)]
struct DataCenter {
    name: String,
    region: String,
    worlds: Vec<u16>,
}

#[derive(Serialize, Deserialize, Debug)]
struct World {
    id: u16,
    name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Item {
    id: u16,
    en: String,
    de: String,
    ja: String,
    fr: String,
}

fn load_items() -> Vec<Item> {
    let file = std::fs::read_to_string("./resources/items.json").unwrap();
    let json: Vec<Item> = serde_json::from_str(&file).unwrap();

    return json
}

async fn autocomplete_item_name_ja<'a>(
    ctx: Context<'_>,
    partial_name: &'a str,
) -> impl Stream<Item = String> +'a {
    futures::stream::iter(
        load_items().iter().map(|item| item.ja.clone()).collect::<Vec<_>>()
    ).filter(move |name| futures::future::ready(name.starts_with(partial_name)))
     .map(|name| name.to_string())
}

#[poise::command(slash_command)]
pub async fn market(
    ctx: Context<'_>, 
    #[description = "The name of item to search"]
    #[autocomplete = "autocomplete_item_name_ja"]
    name: String,
) -> Result<(), Exception> {
    let items = load_items();
    let candidate_items: Vec<&Item> = items.iter().filter(|i| i.ja.contains(&name)).collect();

    let embeds: Vec<CreateEmbed>;

    let client = reqwest::Client::new();
    let baseURL = String::from_str("https://universalis.app").unwrap();


    let dcs = client.get(format!("{}/api/v2/data-centers", baseURL)).send().await.unwrap().json::<Vec<DataCenter>>().await.unwrap();
    let worlds = client.get(format!("{}/api/v2/worlds", baseURL)).send().await.unwrap().json::<Vec<World>>().await.unwrap();

    let available_worlds: Vec<String> = dcs.iter().map(|dc| dc.region.clone()).collect();

    





    Ok(())
}
